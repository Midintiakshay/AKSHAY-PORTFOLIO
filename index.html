<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neon Flow - Pointer Reactive</title>
<!-- Three.js -->
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<style>
  html,body { height:100%; margin:0; background:#000; overflow:hidden; }
  #shader-bg { position:fixed; inset:0; width:100%; height:100%; z-index:-1; display:block; }
  /* keep page content on top for testing */
  .demo-instructions {
    position:fixed; z-index:20; left:18px; top:18px; color:#fff; font-family:Inter, sans-serif;
    background:rgba(0,0,0,0.35); padding:10px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.03)
  }
</style>
</head>
<body>
<canvas id="shader-bg"></canvas>
<div class="demo-instructions">Move mouse / drag finger — colors will flow where you move.</div>
<script>
/*
  Single-file Three.js feedback + splat shader implementation.
  - Black base
  - Pointer injects colorful "splat"
  - Feedback pass advects + fades previous frame -> produces flowing trails
  - Works for mouse and touch
*/
(() => {
  const canvas = document.getElementById('shader-bg');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:false, alpha:false });
  renderer.setPixelRatio(Math.max(1, Math.min(2, window.devicePixelRatio || 1)));
  renderer.autoClear = false;
  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
  // Fullscreen triangle geometry
  const geo = new THREE.BufferGeometry();
  const verts = new Float32Array([-1,-1,0, 3,-1,0, -1,3,0]);
  geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
  // helper to create render targets (ping-pong)
  function makeRT(w,h) {
    return new THREE.WebGLRenderTarget(w,h, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      wrapS: THREE.ClampToEdgeWrapping,
      wrapT: THREE.ClampToEdgeWrapping,
      format: THREE.RGBAFormat,
      type: THREE.UnsignedByteType,
      depthBuffer: false,
      stencilBuffer: false
    });
  }
  // --- fragment that does feedback + small diffusion - main pass ---
  const passFrag = `
    precision highp float;
    uniform sampler2D u_prev;   // previous frame
    uniform vec2 u_res;
    uniform float u_time;
    uniform vec2 u_pointer;     // -1,-1 if inactive
    uniform float u_strength;   // how strong injections are
    uniform float u_decay;      // global decay for feedback
    // simple value noise
    float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123); }
    float noise(vec2 p){
      vec2 i = floor(p);
      vec2 f = fract(p);
      float a = hash(i);
      float b = hash(i + vec2(1.0,0.0));
      float c = hash(i + vec2(0.0,1.0));
      float d = hash(i + vec2(1.0,1.0));
      vec2 u = f*f*(3.0 - 2.0*f);
      return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
    }
    vec3 hsv2rgb(vec3 c){
      vec3 p = abs(fract(c.xxx + vec3(0.0,2.0/3.0,1.0/3.0))*6.0 - 3.0);
      return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
    }
    void main(){
      vec2 uv = gl_FragCoord.xy / u_res;
      vec3 prev = texture2D(u_prev, uv).rgb;
      // base small noise-based motion
      float t = u_time * 0.35;
      float n = noise(uv * 8.0 + vec2(t*0.5, -t*0.4));
      // pointer injection (splat)
      float pointerMask = 0.0;
      vec3 pointerColor = vec3(0.0);
      if(u_pointer.x >= 0.0){
        vec2 ptr = vec2(u_pointer.x, u_pointer.y);
        // convert uv (0..1) to aspect-corrected coords centered
        vec2 asp = vec2(u_res.x/u_res.y, 1.0);
        vec2 pdd = (uv - ptr) * asp;
        float d = length(pdd);
        // tight round falloff
        pointerMask = exp(-d*d*100.0) * u_strength;
        // pick a color that cycles with time & position
        float hue = fract((t*0.15) + (sin(d*12.0) * 0.1) + (pdd.x*0.2));
        pointerColor = hsv2rgb(vec3(hue*0.9 + 0.6, 0.95, 0.7));
      }
      // create subtle ambient glow based on noise (keeps effect alive a bit)
      float ambient = smoothstep(0.35, 0.75, n) * 0.02;
      // current color contribution where pointer is
      vec3 curr = pointerColor * (pointerMask + ambient);
      // add tiny diffusion/blur by sampling neighbours (cheap approximation)
      vec2 px = 1.0 / u_res;
      vec3 neigh = 0.0;
      neigh += texture2D(u_prev, uv + vec2(px.x,0.0)).rgb;
      neigh += texture2D(u_prev, uv + vec2(-px.x,0.0)).rgb;
      neigh += texture2D(u_prev, uv + vec2(0.0,px.y)).rgb;
      neigh += texture2D(u_prev, uv + vec2(0.0,-px.y)).rgb;
      neigh *= 0.25;
      // feedback: combine previous (slightly decayed), neighbor blur, and current injection
      vec3 outCol = prev * u_decay + neigh * 0.25 + curr;
      // tonemap + clamp
      outCol = clamp(outCol, 0.0, 1.5);
      outCol = pow(outCol, vec3(0.9));
      gl_FragColor = vec4(outCol, 1.0);
    }
  `;
  // simple copy shader to draw RT to screen
  const copyFrag = `
    precision highp float;
    uniform sampler2D u_tex;
    uniform vec2 u_res;
    void main(){
      vec2 uv = gl_FragCoord.xy / u_res;
      vec3 c = texture2D(u_tex, uv).rgb;
      gl_FragColor = vec4(c,1.0);
    }
  `;
  // common vertex
  const vert = `
    attribute vec3 position;
    void main(){ gl_Position = vec4(position,1.0); }
  `;
  const passMaterial = new THREE.RawShaderMaterial({
    uniforms: {
      u_prev: { value: null },
      u_res: { value: new THREE.Vector2(512,512) },
      u_time: { value: 0 },
      u_pointer: { value: new THREE.Vector2(-1,-1) },
      u_strength: { value: 1.0 },
      u_decay: { value: 0.94 }
    },
    vertexShader: vert,
    fragmentShader: passFrag,
    depthTest: false,
    depthWrite: false
  });
  const copyMaterial = new THREE.RawShaderMaterial({
    uniforms: {
      u_tex: { value: null },
      u_res: { value: new THREE.Vector2(512,512) }
    },
    vertexShader: vert,
    fragmentShader: copyFrag,
    depthTest: false,
    depthWrite: false
  });
  const mesh = new THREE.Mesh(geo, passMaterial);
  scene.add(mesh);
  let rtA = null, rtB = null;
  function ensureRT(){
    const w = Math.max(2, Math.floor(canvas.clientWidth * renderer.getPixelRatio()));
    const h = Math.max(2, Math.floor(canvas.clientHeight * renderer.getPixelRatio()));
    if(!rtA || rtA.width !== w || rtA.height !== h){
      if(rtA) rtA.dispose();
      if(rtB) rtB.dispose();
      rtA = makeRT(w,h); rtB = makeRT(w,h);
      passMaterial.uniforms.u_res.value.set(w,h);
      copyMaterial.uniforms.u_res.value.set(w,h);
      renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
    }
  }
  ensureRT();
  new ResizeObserver(ensureRT).observe(canvas);
  // Pointer handling
  let pointer = { x:-1, y:-1, active:false };
  function setPointerFromEvent(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    pointer.x = (clientX - r.left) / r.width;
    pointer.y = 1.0 - (clientY - r.top) / r.height; // flip y for shader ease
    pointer.active = true;
  }
  window.addEventListener('mousemove', e => setPointerFromEvent(e.clientX, e.clientY));
  window.addEventListener('touchstart', e => { setPointerFromEvent(e.touches[0].clientX, e.touches[0].clientY); }, {passive:true});
  window.addEventListener('touchmove', e => { setPointerFromEvent(e.touches[0].clientX, e.touches[0].clientY); }, {passive:true});
  window.addEventListener('touchend', () => { pointer.x=-1; pointer.y=-1; pointer.active=false; });
  // Smooth pointer for nicer motion
  let pSmooth = { x:-1, y:-1 };
  function smoothPointer(dt){
    if(pointer.active){
      if(pSmooth.x < 0){ pSmooth.x = pointer.x; pSmooth.y = pointer.y; }
      pSmooth.x += (pointer.x - pSmooth.x) * Math.min(1, 60*dt);
      pSmooth.y += (pointer.y - pSmooth.y) * Math.min(1, 60*dt);
    } else {
      pSmooth.x += (-1 - pSmooth.x) * Math.min(1, 60*dt);
      pSmooth.y += (-1 - pSmooth.y) * Math.min(1, 60*dt);
    }
    return pSmooth;
  }
  // Animation loop: render pass into rtA using rtB as u_prev, then draw rtA to screen, then swap
  let lastTime = performance.now();
  function frame(now){
    ensureRT();
    const dt = Math.min(0.05, (now - lastTime)/1000);
    lastTime = now;
    // update uniforms
    passMaterial.uniforms.u_time.value = now*0.001;
    const sp = smoothPointer(dt);
    // convert back to 0..1 uv coords for shader (we flipped earlier)
    if(sp.x >= 0){
      passMaterial.uniforms.u_pointer.value.set(sp.x, 1.0 - sp.y);
    } else {
      passMaterial.uniforms.u_pointer.value.set(-1, -1);
    }
    passMaterial.uniforms.u_prev.value = rtB.texture;
    // render to rtA
    renderer.setRenderTarget(rtA);
    renderer.clearColor();
    renderer.render(scene, camera);
    // copy rtA to screen
    copyMaterial.uniforms.u_tex.value = rtA.texture;
    // swap mesh material temporarily
    const prevMat = mesh.material;
    mesh.material = copyMaterial;
    renderer.setRenderTarget(null);
    renderer.clear();
    renderer.render(scene, camera);
    mesh.material = prevMat;
    // swap rtA <-> rtB
    [rtA, rtB] = [rtB, rtA];
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
  // expose for debugging (optional)
  window.__NEON = { passMaterial, copyMaterial, renderer };
})();
</script>
</body>
</html>
